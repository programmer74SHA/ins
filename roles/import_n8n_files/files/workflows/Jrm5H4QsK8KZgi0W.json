{
  "id": "Jrm5H4QsK8KZgi0W",
  "name": "SP-AI-EI & AI Summery",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $('Called By Another Workflow').all();\n\n// Prepare containers\nlet privateIPs = [];\nlet publicIPs = [];\nlet hosts = [];\nlet processes = [];\n\n// Extract data from all items\nfor (const item of items) {\n  const data = item.json;\n\n  if (data.PrivateIPs) {\n    privateIPs.push(...data.PrivateIPs);\n  }\n\n  if (data.PublicIPs) {\n    publicIPs.push(...data.PublicIPs);\n  }\n\n  if (data.host) {\n    hosts.push(...data.host);\n  }\n\n  if (data.process) {\n    processes.push(...data.process);\n  }\n}\n\n// Merge all IPs into one list\nconst allIPs = [...privateIPs, ...publicIPs];\n\n// Remove duplicates\nconst uniqueIPs = [...new Set(allIPs)];\nconst uniqueHosts = [...new Set(hosts)];\nconst uniqueProcesses = [...new Set(processes)];\n\n// Return grouped result\nreturn [\n  {\n    json: {\n      IPs: uniqueIPs,\n      Hosts: uniqueHosts,\n      Processes: uniqueProcesses\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1104,
        224
      ],
      "id": "c4ea637f-7d15-4d62-8aee-4bf292ffb9fd",
      "name": "Extract Fields in Alert"
    },
    {
      "parameters": {
        "content": "## Extract and Merge IPs with Host and Process Info\nThis node extracts `PrivateIPs` and `PublicIPs` from the alert input, merges them into a single IP list, and also extracts related `host` and `process` fields. The output JSON contains combined IPs along with host and process details for downstream processing.",
        "height": 320,
        "width": 580,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1456,
        80
      ],
      "typeVersion": 1,
      "id": "40b4c3f7-1da7-4791-a947-84c7167fb36d",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "content": "### Called by Workflows:\n- Splunk AI — SP-AI-Alert-Related Alerts-AI analysis\n- Splunk AI — SP-AI-RL & AI Analysis\n",
        "height": 220,
        "width": 300,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1568,
        -160
      ],
      "typeVersion": 1,
      "id": "ea8dc245-ed37-4f5b-98bb-bae84c406a1a",
      "name": "Sticky Note45"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1392,
        224
      ],
      "id": "9cd96358-752f-400c-b010-811278b74a49",
      "name": "Called By Another Workflow"
    },
    {
      "parameters": {
        "content": "# Version Info:\n\n### Workflow: SP-AI-EI & AI Summery\n### Workflow-Version: 1.0.1\n### Last Updated: 1404-10-20\n### Author: A&A\n### Change: Create for first time\n### Status: InActive",
        "height": 300,
        "width": 560,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1568,
        -480
      ],
      "typeVersion": 1,
      "id": "e0b7bc08-11e6-43fe-96ad-9019682b92ab",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/search?cql=title=\"{{$vars.SP_Confluence_Assets_Page}}\" AND space={{$vars.SP_Confluence_Default_Space}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -496,
        -432
      ],
      "id": "55980864-05be-4af8-ab6f-5fa23de4117c",
      "name": "Get Page AI EI (Assets)",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/search?cql=title=\"{{$vars.SP_Confluence_Network_Zone_Page}}\" AND space={{$vars.SP_Confluence_Default_Space}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -496,
        -240
      ],
      "id": "ac65236b-5fcd-4b4b-a1bb-05352fbe4d30",
      "name": "Get Page AI EI (Network Zone)",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/search?cql=title=\"{{$vars.SP_Confluence_Organization_Working_Time_Page}}\" AND space={{$vars.SP_Confluence_Default_Space}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -496,
        -48
      ],
      "id": "8ab9bf18-f2bb-4df8-a997-d67599e8b902",
      "name": "Get Page AI EI (Organization Working Time)",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/search?cql=title=\"{{$vars.SP_Confluence_Server_Access_Control_Page}}\" AND space={{$vars.SP_Confluence_Default_Space}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -496,
        144
      ],
      "id": "05e0a899-e3f3-4026-96a6-be5ef8f31324",
      "name": "Get Page AI EI (Server Access Control)",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/search?cql=title=\"{{$vars.SP_Confluence_TOIC_Page}}\" AND space={{$vars.SP_Confluence_Default_Space}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -496,
        336
      ],
      "id": "1cb8ff0b-3b72-4624-8a60-4b1f21fca68c",
      "name": "Get Page AI EI (Trusted Outbound Internet Connections)",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/search?cql=title=\"{{$vars.SP_Confluence_Users_Access_Control_Page}}\" AND space={{$vars.SP_Confluence_Default_Space}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -496,
        528
      ],
      "id": "2c98aa24-3ca7-4807-8370-3958be684662",
      "name": "Get Page AI EI (User's Access Control)",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/{{ $json.results[0].id }}?expand=body.storage",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -272,
        -432
      ],
      "id": "c9859af4-0ed3-45a9-8236-7ac0f5b17882",
      "name": "Get content AI EI (Assets) by page ID",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/{{ $json.results[0].id }}?expand=body.storage",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -272,
        -48
      ],
      "id": "05ce0da4-76a4-4777-897a-ecde9daf1f87",
      "name": "Get content  AI EI (Organization Working Time) by page ID",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/{{ $json.results[0].id }}?expand=body.storage",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -272,
        -240
      ],
      "id": "adde7b3a-f9bd-4187-a522-f2b8b2ba54dc",
      "name": "Get content AI EI (Network Zone) by page ID",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/{{ $json.results[0].id }}?expand=body.storage",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -272,
        144
      ],
      "id": "5e9ec135-5bd6-46f5-8fe2-c14558290922",
      "name": "Get content AI EI (Server Access Control) by page ID",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/{{ $json.results[0].id }}?expand=body.storage",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -272,
        336
      ],
      "id": "6c7d16c9-b1fb-4b87-93c0-f1c9325e4a43",
      "name": "Get content AI EI (Trusted Outbound Internet Connections) by page ID",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$vars.SP_Confluence_Base_URL}}/rest/api/content/{{ $json.results[0].id }}?expand=body.storage",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -272,
        528
      ],
      "id": "628c4725-8765-43ca-b870-cacd0c0e5fb6",
      "name": "Get content AI EI (User's Access Control) by page ID",
      "credentials": {
        "httpBasicAuth": {
          "id": "TBvaC0lfPhn2y3tL",
          "name": "Confluence"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const html = $input.first().json.body.storage.value;\n\n// --- 1. Extract table ---\nconst rowMatches = html.match(/<tr>([\\s\\S]*?)<\\/tr>/gi);\nlet tableData = [];\n\nif (rowMatches && rowMatches.length > 0) {\n    // Extract headers from the first row\n    const headerRow = rowMatches[0];\n    const headers = Array.from(headerRow.matchAll(/<t[h|d][^>]*>([\\s\\S]*?)<\\/t[h|d]>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n\n    // Extract remaining rows\n    tableData = rowMatches.slice(1).map(row => {\n        const cells = Array.from(row.matchAll(/<td[^>]*>([\\s\\S]*?)<\\/td>/gi))\n            .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n        if (cells.length === 0) return null;\n        const obj = {};\n        headers.forEach((h, i) => obj[h] = cells[i] || '');\n        return obj;\n    }).filter(r => r !== null);\n}\n\n// --- 2. Extract field descriptions & examples ---\nconst htmlWithoutTable = html.replace(/<table[\\s\\S]*?<\\/table>/gi, '');\n\n// Match all <strong>field name</strong> followed by one or more <p>\nconst fieldMatches = Array.from(htmlWithoutTable.matchAll(/<strong>(.*?)<\\/strong>([\\s\\S]*?)(?=(<strong>|$))/gi));\n\nlet fields = {};\n\nfieldMatches.forEach(match => {\n    const fieldName = match[1].replace(/<[^>]+>/g, '').trim();\n    if (!fieldName || /row id/i.test(fieldName)) return;\n\n    // Get all <p> within this block\n    const pMatches = Array.from(match[2].matchAll(/<p[^>]*>([\\s\\S]*?)<\\/p>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim())\n        .filter(t => t);\n\n    let description = '';\n    let example = '';\n\n    if (pMatches.length > 0) {\n        description = pMatches[0].replace(/^(Description:)/i, '').trim();\n        if (pMatches.length > 1 && /example/i.test(pMatches[1])) {\n            example = pMatches[1].replace(/^(Example:)/i, '').trim();\n        }\n    }\n\n    fields[fieldName] = { description, example };\n});\n\n// --- 3. Return single item ---\nreturn [\n    {\n        json: {\n            table: tableData,\n            fields: fields\n        }\n    }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        -432
      ],
      "id": "717db159-ce14-493a-86e3-741235907a4b",
      "name": "Get Content of AI EI (Assets)"
    },
    {
      "parameters": {
        "jsCode": "const html = $input.first().json.body.storage.value;\n\n// --- 1. Extract table ---\nconst rowMatches = html.match(/<tr>([\\s\\S]*?)<\\/tr>/gi);\nlet tableData = [];\n\nif (rowMatches && rowMatches.length > 0) {\n    // Extract headers from the first row\n    const headerRow = rowMatches[0];\n    const headers = Array.from(headerRow.matchAll(/<t[h|d][^>]*>([\\s\\S]*?)<\\/t[h|d]>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n\n    // Extract remaining rows\n    tableData = rowMatches.slice(1).map(row => {\n        const cells = Array.from(row.matchAll(/<td[^>]*>([\\s\\S]*?)<\\/td>/gi))\n            .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n        if (cells.length === 0) return null;\n        const obj = {};\n        headers.forEach((h, i) => obj[h] = cells[i] || '');\n        return obj;\n    }).filter(r => r !== null);\n}\n\n// --- 2. Extract field descriptions & examples ---\nconst htmlWithoutTable = html.replace(/<table[\\s\\S]*?<\\/table>/gi, '');\n\n// Match all <strong>field name</strong> followed by one or more <p>\nconst fieldMatches = Array.from(htmlWithoutTable.matchAll(/<strong>(.*?)<\\/strong>([\\s\\S]*?)(?=(<strong>|$))/gi));\n\nlet fields = {};\n\nfieldMatches.forEach(match => {\n    const fieldName = match[1].replace(/<[^>]+>/g, '').trim();\n    if (!fieldName || /row id/i.test(fieldName)) return;\n\n    // Get all <p> within this block\n    const pMatches = Array.from(match[2].matchAll(/<p[^>]*>([\\s\\S]*?)<\\/p>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim())\n        .filter(t => t);\n\n    let description = '';\n    let example = '';\n\n    if (pMatches.length > 0) {\n        description = pMatches[0].replace(/^(Description:)/i, '').trim();\n        if (pMatches.length > 1 && /example/i.test(pMatches[1])) {\n            example = pMatches[1].replace(/^(Example:)/i, '').trim();\n        }\n    }\n\n    fields[fieldName] = { description, example };\n});\n\n// --- 3. Return single item ---\nreturn [\n    {\n        json: {\n            table: tableData,\n            fields: fields\n        }\n    }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        -240
      ],
      "id": "44a65c35-ee3a-4e96-a149-8e0397bf6674",
      "name": "Get Content of AI EI (Network Zone)"
    },
    {
      "parameters": {
        "jsCode": "const html = $input.first().json.body.storage.value;\n\n// --- 1. Extract table ---\nconst rowMatches = html.match(/<tr>([\\s\\S]*?)<\\/tr>/gi);\nlet tableData = [];\n\nif (rowMatches && rowMatches.length > 0) {\n    // Extract headers from the first row\n    const headerRow = rowMatches[0];\n    const headers = Array.from(headerRow.matchAll(/<t[h|d][^>]*>([\\s\\S]*?)<\\/t[h|d]>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n\n    // Extract remaining rows\n    tableData = rowMatches.slice(1).map(row => {\n        const cells = Array.from(row.matchAll(/<td[^>]*>([\\s\\S]*?)<\\/td>/gi))\n            .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n        if (cells.length === 0) return null;\n        const obj = {};\n        headers.forEach((h, i) => obj[h] = cells[i] || '');\n        return obj;\n    }).filter(r => r !== null);\n}\n\n// --- 2. Extract field descriptions & examples ---\nconst htmlWithoutTable = html.replace(/<table[\\s\\S]*?<\\/table>/gi, '');\n\n// Match all <strong>field name</strong> followed by one or more <p>\nconst fieldMatches = Array.from(htmlWithoutTable.matchAll(/<strong>(.*?)<\\/strong>([\\s\\S]*?)(?=(<strong>|$))/gi));\n\nlet fields = {};\n\nfieldMatches.forEach(match => {\n    const fieldName = match[1].replace(/<[^>]+>/g, '').trim();\n    if (!fieldName || /row id/i.test(fieldName)) return;\n\n    // Get all <p> within this block\n    const pMatches = Array.from(match[2].matchAll(/<p[^>]*>([\\s\\S]*?)<\\/p>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim())\n        .filter(t => t);\n\n    let description = '';\n    let example = '';\n\n    if (pMatches.length > 0) {\n        description = pMatches[0].replace(/^(Description:)/i, '').trim();\n        if (pMatches.length > 1 && /example/i.test(pMatches[1])) {\n            example = pMatches[1].replace(/^(Example:)/i, '').trim();\n        }\n    }\n\n    fields[fieldName] = { description, example };\n});\n\n// --- 3. Return single item ---\nreturn [\n    {\n        json: {\n            table: tableData,\n            fields: fields\n        }\n    }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        -48
      ],
      "id": "25a42ba7-4a66-4058-964f-fea6a4e8a5d0",
      "name": "Get Content of  AI EI (Organization Working Time)"
    },
    {
      "parameters": {
        "jsCode": "const html = $input.first().json.body.storage.value;\n\n// --- 1. Extract table ---\nconst rowMatches = html.match(/<tr>([\\s\\S]*?)<\\/tr>/gi);\nlet tableData = [];\n\nif (rowMatches && rowMatches.length > 0) {\n    // Extract headers from the first row\n    const headerRow = rowMatches[0];\n    const headers = Array.from(headerRow.matchAll(/<t[h|d][^>]*>([\\s\\S]*?)<\\/t[h|d]>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n\n    // Extract remaining rows\n    tableData = rowMatches.slice(1).map(row => {\n        const cells = Array.from(row.matchAll(/<td[^>]*>([\\s\\S]*?)<\\/td>/gi))\n            .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n        if (cells.length === 0) return null;\n        const obj = {};\n        headers.forEach((h, i) => obj[h] = cells[i] || '');\n        return obj;\n    }).filter(r => r !== null);\n}\n\n// --- 2. Extract field descriptions & examples ---\nconst htmlWithoutTable = html.replace(/<table[\\s\\S]*?<\\/table>/gi, '');\n\n// Match all <strong>field name</strong> followed by one or more <p>\nconst fieldMatches = Array.from(htmlWithoutTable.matchAll(/<strong>(.*?)<\\/strong>([\\s\\S]*?)(?=(<strong>|$))/gi));\n\nlet fields = {};\n\nfieldMatches.forEach(match => {\n    const fieldName = match[1].replace(/<[^>]+>/g, '').trim();\n    if (!fieldName || /row id/i.test(fieldName)) return;\n\n    // Get all <p> within this block\n    const pMatches = Array.from(match[2].matchAll(/<p[^>]*>([\\s\\S]*?)<\\/p>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim())\n        .filter(t => t);\n\n    let description = '';\n    let example = '';\n\n    if (pMatches.length > 0) {\n        description = pMatches[0].replace(/^(Description:)/i, '').trim();\n        if (pMatches.length > 1 && /example/i.test(pMatches[1])) {\n            example = pMatches[1].replace(/^(Example:)/i, '').trim();\n        }\n    }\n\n    fields[fieldName] = { description, example };\n});\n\n// --- 3. Return single item ---\nreturn [\n    {\n        json: {\n            table: tableData,\n            fields: fields\n        }\n    }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        144
      ],
      "id": "0071fa63-3f07-4209-9bd7-49df91b0c111",
      "name": "Get Content ofAI EI (User's Access Control)"
    },
    {
      "parameters": {
        "jsCode": "const html = $input.first().json.body.storage.value;\n\n// --- 1. Extract table ---\nconst rowMatches = html.match(/<tr>([\\s\\S]*?)<\\/tr>/gi);\nlet tableData = [];\n\nif (rowMatches && rowMatches.length > 0) {\n    // Extract headers from the first row\n    const headerRow = rowMatches[0];\n    const headers = Array.from(headerRow.matchAll(/<t[h|d][^>]*>([\\s\\S]*?)<\\/t[h|d]>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n\n    // Extract remaining rows\n    tableData = rowMatches.slice(1).map(row => {\n        const cells = Array.from(row.matchAll(/<td[^>]*>([\\s\\S]*?)<\\/td>/gi))\n            .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n        if (cells.length === 0) return null;\n        const obj = {};\n        headers.forEach((h, i) => obj[h] = cells[i] || '');\n        return obj;\n    }).filter(r => r !== null);\n}\n\n// --- 2. Extract field descriptions & examples ---\nconst htmlWithoutTable = html.replace(/<table[\\s\\S]*?<\\/table>/gi, '');\n\n// Match all <strong>field name</strong> followed by one or more <p>\nconst fieldMatches = Array.from(htmlWithoutTable.matchAll(/<strong>(.*?)<\\/strong>([\\s\\S]*?)(?=(<strong>|$))/gi));\n\nlet fields = {};\n\nfieldMatches.forEach(match => {\n    const fieldName = match[1].replace(/<[^>]+>/g, '').trim();\n    if (!fieldName || /row id/i.test(fieldName)) return;\n\n    // Get all <p> within this block\n    const pMatches = Array.from(match[2].matchAll(/<p[^>]*>([\\s\\S]*?)<\\/p>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim())\n        .filter(t => t);\n\n    let description = '';\n    let example = '';\n\n    if (pMatches.length > 0) {\n        description = pMatches[0].replace(/^(Description:)/i, '').trim();\n        if (pMatches.length > 1 && /example/i.test(pMatches[1])) {\n            example = pMatches[1].replace(/^(Example:)/i, '').trim();\n        }\n    }\n\n    fields[fieldName] = { description, example };\n});\n\n// --- 3. Return single item ---\nreturn [\n    {\n        json: {\n            table: tableData,\n            fields: fields\n        }\n    }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        336
      ],
      "id": "655e6385-a588-4ff9-9352-148edd11e086",
      "name": "Get Content of AI EI (Trusted Outbound Internet Connections)"
    },
    {
      "parameters": {
        "jsCode": "const html = $input.first().json.body.storage.value;\n\n// --- 1. Extract table ---\nconst rowMatches = html.match(/<tr>([\\s\\S]*?)<\\/tr>/gi);\nlet tableData = [];\n\nif (rowMatches && rowMatches.length > 0) {\n    // Extract headers from the first row\n    const headerRow = rowMatches[0];\n    const headers = Array.from(headerRow.matchAll(/<t[h|d][^>]*>([\\s\\S]*?)<\\/t[h|d]>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n\n    // Extract remaining rows\n    tableData = rowMatches.slice(1).map(row => {\n        const cells = Array.from(row.matchAll(/<td[^>]*>([\\s\\S]*?)<\\/td>/gi))\n            .map(m => m[1].replace(/<[^>]+>/g, '').trim());\n        if (cells.length === 0) return null;\n        const obj = {};\n        headers.forEach((h, i) => obj[h] = cells[i] || '');\n        return obj;\n    }).filter(r => r !== null);\n}\n\n// --- 2. Extract field descriptions & examples ---\nconst htmlWithoutTable = html.replace(/<table[\\s\\S]*?<\\/table>/gi, '');\n\n// Match all <strong>field name</strong> followed by one or more <p>\nconst fieldMatches = Array.from(htmlWithoutTable.matchAll(/<strong>(.*?)<\\/strong>([\\s\\S]*?)(?=(<strong>|$))/gi));\n\nlet fields = {};\n\nfieldMatches.forEach(match => {\n    const fieldName = match[1].replace(/<[^>]+>/g, '').trim();\n    if (!fieldName || /row id/i.test(fieldName)) return;\n\n    // Get all <p> within this block\n    const pMatches = Array.from(match[2].matchAll(/<p[^>]*>([\\s\\S]*?)<\\/p>/gi))\n        .map(m => m[1].replace(/<[^>]+>/g, '').trim())\n        .filter(t => t);\n\n    let description = '';\n    let example = '';\n\n    if (pMatches.length > 0) {\n        description = pMatches[0].replace(/^(Description:)/i, '').trim();\n        if (pMatches.length > 1 && /example/i.test(pMatches[1])) {\n            example = pMatches[1].replace(/^(Example:)/i, '').trim();\n        }\n    }\n\n    fields[fieldName] = { description, example };\n});\n\n// --- 3. Return single item ---\nreturn [\n    {\n        json: {\n            table: tableData,\n            fields: fields\n        }\n    }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        528
      ],
      "id": "c82c9762-36f6-44fd-8394-6c9e22e391fc",
      "name": "Get Content of  AI EI (User's Access Control)"
    },
    {
      "parameters": {
        "jsCode": "// --------------------------------------------\n// Helper: Convert IP → int\n// --------------------------------------------\nfunction ipToInt(ip) {\n    const p = ip.split('.');\n    if (p.length !== 4) return null;\n    return p.reduce((acc, part) => (acc << 8) + parseInt(part, 10), 0) >>> 0;\n}\n\n// --------------------------------------------\n// Helper: Check if IP belongs to CIDR\n// --------------------------------------------\nfunction ipInCidr(ip, cidr) {\n    if (!cidr.includes(\"/\")) return false;\n    const [cidrIp, mask] = cidr.split(\"/\");\n    const m = parseInt(mask, 10);\n\n    const ipInt = ipToInt(ip);\n    const cidrInt = ipToInt(cidrIp);\n    if (ipInt === null || cidrInt === null) return false;\n\n    const maskInt = m === 0 ? 0 : (~0 << (32 - m)) >>> 0;\n    return (ipInt & maskInt) === (cidrInt & maskInt);\n}\n\n// --------------------------------------------\n// Helper: Extract IP or CIDR patterns\n// --------------------------------------------\nfunction extractIpOrCidr(str) {\n    if (typeof str !== \"string\") return [];\n    const regex = /\\b\\d{1,3}(?:\\.\\d{1,3}){3}(?:\\/\\d{1,2})?\\b/g;\n    return str.match(regex) || [];\n}\n\n// --------------------------------------------\n// Helper: service:port detection (flexible)\n// --------------------------------------------\nfunction isServicePortFormat(str) {\n    return /^[A-Za-z0-9_\\-\\.]+\\s*:\\s*\\d{1,5}$/.test(str.trim());\n}\n\n// --------------------------------------------\n// READ NEW INPUT FORMAT\n// --------------------------------------------\nlet alert = $('Extract Fields in Alert').item.json;\n\n// Ensure array\nif (!Array.isArray(alert)) alert = [alert];\n\n// Pick first alert (you only provide one)\nconst alertObj = alert[0] || {};\n\n// Build alert value lists\nconst alertIPs = Array.isArray(alertObj.IPs) ? alertObj.IPs : [];\nconst alertHosts = Array.isArray(alertObj.Hosts) ? alertObj.Hosts : [];\nconst alertProcesses = Array.isArray(alertObj.Processes) ? alertObj.Processes : [];\n\n// Combine hostnames + processes for text searching\nconst alertValues = [...alertHosts, ...alertProcesses];\n\n// --------------------------------------------\n// GET TABLE DATA\n// --------------------------------------------\nconst tableData = $input.first().json.table;\n\nif (!tableData || !Array.isArray(tableData)) {\n    return [{ json: { message: \"No table found in input\", count: 0 } }];\n}\n\n// --------------------------------------------\n// MATCHING ENGINE\n// --------------------------------------------\nfunction findMatchedValues(row, alertValues, alertIPs) {\n    const matched = [];\n    const rowValues = Object.values(row).filter(v => v);\n\n    rowValues.forEach(cell => {\n        const cellStr = cell.toString();\n\n        // Split into parts\n        const parts = cellStr.split(/[,;]+/).map(p => p.trim());\n\n        parts.forEach(part => {\n\n            // ❌ Skip \"ssh : 22\" etc.\n            if (isServicePortFormat(part)) return;\n\n            // TEXT match for Hosts + Processes\n            alertValues.forEach(val => {\n                if (part.includes(val) && !matched.includes(val)) {\n                    matched.push(val);\n                }\n            });\n\n            // IP/CIDR matches\n            const foundPatterns = extractIpOrCidr(part);\n\n            foundPatterns.forEach(pattern => {\n                if (pattern.includes(\"/\")) {\n                    alertIPs.forEach(ip => {\n                        if (ipInCidr(ip, pattern) && !matched.includes(ip)) {\n                            matched.push(ip);\n                        }\n                    });\n                } else if (/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(pattern)) {\n                    if (alertIPs.includes(pattern) && !matched.includes(pattern)) {\n                        matched.push(pattern);\n                    }\n                }\n            });\n\n        });\n    });\n\n    return matched;\n}\n\n// --------------------------------------------\n// RUN MATCHING\n// --------------------------------------------\nlet globalMatchedValues = [];\nconst matchedRows = [];\n\ntableData.forEach(row => {\n    const rowMatches = findMatchedValues(row, alertValues, alertIPs);\n\n    if (rowMatches.length > 0) {\n        matchedRows.push(row);\n        rowMatches.forEach(v => {\n            if (!globalMatchedValues.includes(v)) {\n                globalMatchedValues.push(v);\n            }\n        });\n    }\n});\n\n// --------------------------------------------\n// RETURN OUTPUT\n// --------------------------------------------\nif (matchedRows.length === 0) {\n    return [{\n        json: {\n            message: \"No matching rows found\",\n            count: 0\n        }\n    }];\n}\n\nreturn [{\n    json: {\n        message: \"Matching rows found\",\n        count: matchedRows.length,\n        matchedValues: globalMatchedValues,\n        rows: matchedRows\n    }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        -432
      ],
      "id": "b99661f7-d1fd-4635-804c-8b7b185c6005",
      "name": "Get Match AI EI (Assets)"
    },
    {
      "parameters": {
        "jsCode": "// --------------------------------------------\n// Helper: Convert IP → int\n// --------------------------------------------\nfunction ipToInt(ip) {\n    const p = ip.split('.');\n    if (p.length !== 4) return null;\n    return p.reduce((acc, part) => (acc << 8) + parseInt(part, 10), 0) >>> 0;\n}\n\n// --------------------------------------------\n// Helper: Check if IP belongs to CIDR\n// --------------------------------------------\nfunction ipInCidr(ip, cidr) {\n    if (!cidr.includes(\"/\")) return false;\n    const [cidrIp, mask] = cidr.split(\"/\");\n    const m = parseInt(mask, 10);\n\n    const ipInt = ipToInt(ip);\n    const cidrInt = ipToInt(cidrIp);\n    if (ipInt === null || cidrInt === null) return false;\n\n    const maskInt = m === 0 ? 0 : (~0 << (32 - m)) >>> 0;\n    return (ipInt & maskInt) === (cidrInt & maskInt);\n}\n\n// --------------------------------------------\n// Helper: Extract IP or CIDR patterns\n// --------------------------------------------\nfunction extractIpOrCidr(str) {\n    if (typeof str !== \"string\") return [];\n    const regex = /\\b\\d{1,3}(?:\\.\\d{1,3}){3}(?:\\/\\d{1,2})?\\b/g;\n    return str.match(regex) || [];\n}\n\n// --------------------------------------------\n// Helper: service:port detection (flexible)\n// --------------------------------------------\nfunction isServicePortFormat(str) {\n    return /^[A-Za-z0-9_\\-\\.]+\\s*:\\s*\\d{1,5}$/.test(str.trim());\n}\n\n// --------------------------------------------\n// READ NEW INPUT FORMAT\n// --------------------------------------------\nlet alert = $('Extract Fields in Alert').item.json;\n\n// Ensure array\nif (!Array.isArray(alert)) alert = [alert];\n\n// Pick first alert (you only provide one)\nconst alertObj = alert[0] || {};\n\n// Build alert value lists\nconst alertIPs = Array.isArray(alertObj.IPs) ? alertObj.IPs : [];\nconst alertHosts = Array.isArray(alertObj.Hosts) ? alertObj.Hosts : [];\nconst alertProcesses = Array.isArray(alertObj.Processes) ? alertObj.Processes : [];\n\n// Combine hostnames + processes for text searching\nconst alertValues = [...alertHosts, ...alertProcesses];\n\n// --------------------------------------------\n// GET TABLE DATA\n// --------------------------------------------\nconst tableData = $input.first().json.table;\n\nif (!tableData || !Array.isArray(tableData)) {\n    return [{ json: { message: \"No table found in input\", count: 0 } }];\n}\n\n// --------------------------------------------\n// MATCHING ENGINE\n// --------------------------------------------\nfunction findMatchedValues(row, alertValues, alertIPs) {\n    const matched = [];\n    const rowValues = Object.values(row).filter(v => v);\n\n    rowValues.forEach(cell => {\n        const cellStr = cell.toString();\n\n        // Split into parts\n        const parts = cellStr.split(/[,;]+/).map(p => p.trim());\n\n        parts.forEach(part => {\n\n            // ❌ Skip \"ssh : 22\" etc.\n            if (isServicePortFormat(part)) return;\n\n            // TEXT match for Hosts + Processes\n            alertValues.forEach(val => {\n                if (part.includes(val) && !matched.includes(val)) {\n                    matched.push(val);\n                }\n            });\n\n            // IP/CIDR matches\n            const foundPatterns = extractIpOrCidr(part);\n\n            foundPatterns.forEach(pattern => {\n                if (pattern.includes(\"/\")) {\n                    alertIPs.forEach(ip => {\n                        if (ipInCidr(ip, pattern) && !matched.includes(ip)) {\n                            matched.push(ip);\n                        }\n                    });\n                } else if (/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(pattern)) {\n                    if (alertIPs.includes(pattern) && !matched.includes(pattern)) {\n                        matched.push(pattern);\n                    }\n                }\n            });\n\n        });\n    });\n\n    return matched;\n}\n\n// --------------------------------------------\n// RUN MATCHING\n// --------------------------------------------\nlet globalMatchedValues = [];\nconst matchedRows = [];\n\ntableData.forEach(row => {\n    const rowMatches = findMatchedValues(row, alertValues, alertIPs);\n\n    if (rowMatches.length > 0) {\n        matchedRows.push(row);\n        rowMatches.forEach(v => {\n            if (!globalMatchedValues.includes(v)) {\n                globalMatchedValues.push(v);\n            }\n        });\n    }\n});\n\n// --------------------------------------------\n// RETURN OUTPUT\n// --------------------------------------------\nif (matchedRows.length === 0) {\n    return [{\n        json: {\n            message: \"No matching rows found\",\n            count: 0\n        }\n    }];\n}\n\nreturn [{\n    json: {\n        message: \"Matching rows found\",\n        count: matchedRows.length,\n        matchedValues: globalMatchedValues,\n        rows: matchedRows\n    }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        -240
      ],
      "id": "f7a4b42e-b784-407c-90b6-a392389d0249",
      "name": "Gat Match AI EI (Network Zone)"
    },
    {
      "parameters": {
        "jsCode": "// --------------------------------------------\n// Helper: Convert IP → int\n// --------------------------------------------\nfunction ipToInt(ip) {\n    const p = ip.split('.');\n    if (p.length !== 4) return null;\n    return p.reduce((acc, part) => (acc << 8) + parseInt(part, 10), 0) >>> 0;\n}\n\n// --------------------------------------------\n// Helper: Check if IP belongs to CIDR\n// --------------------------------------------\nfunction ipInCidr(ip, cidr) {\n    if (!cidr.includes(\"/\")) return false;\n    const [cidrIp, mask] = cidr.split(\"/\");\n    const m = parseInt(mask, 10);\n\n    const ipInt = ipToInt(ip);\n    const cidrInt = ipToInt(cidrIp);\n    if (ipInt === null || cidrInt === null) return false;\n\n    const maskInt = m === 0 ? 0 : (~0 << (32 - m)) >>> 0;\n    return (ipInt & maskInt) === (cidrInt & maskInt);\n}\n\n// --------------------------------------------\n// Helper: Extract IP or CIDR patterns\n// --------------------------------------------\nfunction extractIpOrCidr(str) {\n    if (typeof str !== \"string\") return [];\n    const regex = /\\b\\d{1,3}(?:\\.\\d{1,3}){3}(?:\\/\\d{1,2})?\\b/g;\n    return str.match(regex) || [];\n}\n\n// --------------------------------------------\n// Helper: service:port detection (flexible)\n// --------------------------------------------\nfunction isServicePortFormat(str) {\n    return /^[A-Za-z0-9_\\-\\.]+\\s*:\\s*\\d{1,5}$/.test(str.trim());\n}\n\n// --------------------------------------------\n// READ NEW INPUT FORMAT\n// --------------------------------------------\nlet alert = $('Extract Fields in Alert').item.json;\n\n// Ensure array\nif (!Array.isArray(alert)) alert = [alert];\n\n// Pick first alert (you only provide one)\nconst alertObj = alert[0] || {};\n\n// Build alert value lists\nconst alertIPs = Array.isArray(alertObj.IPs) ? alertObj.IPs : [];\nconst alertHosts = Array.isArray(alertObj.Hosts) ? alertObj.Hosts : [];\nconst alertProcesses = Array.isArray(alertObj.Processes) ? alertObj.Processes : [];\n\n// Combine hostnames + processes for text searching\nconst alertValues = [...alertHosts, ...alertProcesses];\n\n// --------------------------------------------\n// GET TABLE DATA\n// --------------------------------------------\nconst tableData = $input.first().json.table;\n\nif (!tableData || !Array.isArray(tableData)) {\n    return [{ json: { message: \"No table found in input\", count: 0 } }];\n}\n\n// --------------------------------------------\n// MATCHING ENGINE\n// --------------------------------------------\nfunction findMatchedValues(row, alertValues, alertIPs) {\n    const matched = [];\n    const rowValues = Object.values(row).filter(v => v);\n\n    rowValues.forEach(cell => {\n        const cellStr = cell.toString();\n\n        // Split into parts\n        const parts = cellStr.split(/[,;]+/).map(p => p.trim());\n\n        parts.forEach(part => {\n\n            // ❌ Skip \"ssh : 22\" etc.\n            if (isServicePortFormat(part)) return;\n\n            // TEXT match for Hosts + Processes\n            alertValues.forEach(val => {\n                if (part.includes(val) && !matched.includes(val)) {\n                    matched.push(val);\n                }\n            });\n\n            // IP/CIDR matches\n            const foundPatterns = extractIpOrCidr(part);\n\n            foundPatterns.forEach(pattern => {\n                if (pattern.includes(\"/\")) {\n                    alertIPs.forEach(ip => {\n                        if (ipInCidr(ip, pattern) && !matched.includes(ip)) {\n                            matched.push(ip);\n                        }\n                    });\n                } else if (/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(pattern)) {\n                    if (alertIPs.includes(pattern) && !matched.includes(pattern)) {\n                        matched.push(pattern);\n                    }\n                }\n            });\n\n        });\n    });\n\n    return matched;\n}\n\n// --------------------------------------------\n// RUN MATCHING\n// --------------------------------------------\nlet globalMatchedValues = [];\nconst matchedRows = [];\n\ntableData.forEach(row => {\n    const rowMatches = findMatchedValues(row, alertValues, alertIPs);\n\n    if (rowMatches.length > 0) {\n        matchedRows.push(row);\n        rowMatches.forEach(v => {\n            if (!globalMatchedValues.includes(v)) {\n                globalMatchedValues.push(v);\n            }\n        });\n    }\n});\n\n// --------------------------------------------\n// RETURN OUTPUT\n// --------------------------------------------\nif (matchedRows.length === 0) {\n    return [{\n        json: {\n            message: \"No matching rows found\",\n            count: 0\n        }\n    }];\n}\n\nreturn [{\n    json: {\n        message: \"Matching rows found\",\n        count: matchedRows.length,\n        matchedValues: globalMatchedValues,\n        rows: matchedRows\n    }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        -48
      ],
      "id": "e86c0043-a84f-410b-a499-81a7afa79752",
      "name": "Get Match  AI EI (Organization Working Time)"
    },
    {
      "parameters": {
        "jsCode": "// --------------------------------------------\n// Helper: Convert IP → int\n// --------------------------------------------\nfunction ipToInt(ip) {\n    const p = ip.split('.');\n    if (p.length !== 4) return null;\n    return p.reduce((acc, part) => (acc << 8) + parseInt(part, 10), 0) >>> 0;\n}\n\n// --------------------------------------------\n// Helper: Check if IP belongs to CIDR\n// --------------------------------------------\nfunction ipInCidr(ip, cidr) {\n    if (!cidr.includes(\"/\")) return false;\n    const [cidrIp, mask] = cidr.split(\"/\");\n    const m = parseInt(mask, 10);\n\n    const ipInt = ipToInt(ip);\n    const cidrInt = ipToInt(cidrIp);\n    if (ipInt === null || cidrInt === null) return false;\n\n    const maskInt = m === 0 ? 0 : (~0 << (32 - m)) >>> 0;\n    return (ipInt & maskInt) === (cidrInt & maskInt);\n}\n\n// --------------------------------------------\n// Helper: Extract IP or CIDR patterns\n// --------------------------------------------\nfunction extractIpOrCidr(str) {\n    if (typeof str !== \"string\") return [];\n    const regex = /\\b\\d{1,3}(?:\\.\\d{1,3}){3}(?:\\/\\d{1,2})?\\b/g;\n    return str.match(regex) || [];\n}\n\n// --------------------------------------------\n// Helper: service:port detection (flexible)\n// --------------------------------------------\nfunction isServicePortFormat(str) {\n    return /^[A-Za-z0-9_\\-\\.]+\\s*:\\s*\\d{1,5}$/.test(str.trim());\n}\n\n// --------------------------------------------\n// READ NEW INPUT FORMAT\n// --------------------------------------------\nlet alert = $('Extract Fields in Alert').item.json;\n\n// Ensure array\nif (!Array.isArray(alert)) alert = [alert];\n\n// Pick first alert (you only provide one)\nconst alertObj = alert[0] || {};\n\n// Build alert value lists\nconst alertIPs = Array.isArray(alertObj.IPs) ? alertObj.IPs : [];\nconst alertHosts = Array.isArray(alertObj.Hosts) ? alertObj.Hosts : [];\nconst alertProcesses = Array.isArray(alertObj.Processes) ? alertObj.Processes : [];\n\n// Combine hostnames + processes for text searching\nconst alertValues = [...alertHosts, ...alertProcesses];\n\n// --------------------------------------------\n// GET TABLE DATA\n// --------------------------------------------\nconst tableData = $input.first().json.table;\n\nif (!tableData || !Array.isArray(tableData)) {\n    return [{ json: { message: \"No table found in input\", count: 0 } }];\n}\n\n// --------------------------------------------\n// MATCHING ENGINE\n// --------------------------------------------\nfunction findMatchedValues(row, alertValues, alertIPs) {\n    const matched = [];\n    const rowValues = Object.values(row).filter(v => v);\n\n    rowValues.forEach(cell => {\n        const cellStr = cell.toString();\n\n        // Split into parts\n        const parts = cellStr.split(/[,;]+/).map(p => p.trim());\n\n        parts.forEach(part => {\n\n            // ❌ Skip \"ssh : 22\" etc.\n            if (isServicePortFormat(part)) return;\n\n            // TEXT match for Hosts + Processes\n            alertValues.forEach(val => {\n                if (part.includes(val) && !matched.includes(val)) {\n                    matched.push(val);\n                }\n            });\n\n            // IP/CIDR matches\n            const foundPatterns = extractIpOrCidr(part);\n\n            foundPatterns.forEach(pattern => {\n                if (pattern.includes(\"/\")) {\n                    alertIPs.forEach(ip => {\n                        if (ipInCidr(ip, pattern) && !matched.includes(ip)) {\n                            matched.push(ip);\n                        }\n                    });\n                } else if (/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(pattern)) {\n                    if (alertIPs.includes(pattern) && !matched.includes(pattern)) {\n                        matched.push(pattern);\n                    }\n                }\n            });\n\n        });\n    });\n\n    return matched;\n}\n\n// --------------------------------------------\n// RUN MATCHING\n// --------------------------------------------\nlet globalMatchedValues = [];\nconst matchedRows = [];\n\ntableData.forEach(row => {\n    const rowMatches = findMatchedValues(row, alertValues, alertIPs);\n\n    if (rowMatches.length > 0) {\n        matchedRows.push(row);\n        rowMatches.forEach(v => {\n            if (!globalMatchedValues.includes(v)) {\n                globalMatchedValues.push(v);\n            }\n        });\n    }\n});\n\n// --------------------------------------------\n// RETURN OUTPUT\n// --------------------------------------------\nif (matchedRows.length === 0) {\n    return [{\n        json: {\n            message: \"No matching rows found\",\n            count: 0\n        }\n    }];\n}\n\nreturn [{\n    json: {\n        message: \"Matching rows found\",\n        count: matchedRows.length,\n        matchedValues: globalMatchedValues,\n        rows: matchedRows\n    }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        144
      ],
      "id": "92303489-9b25-4adc-a7fc-7b89d6b84450",
      "name": "Get Match AI EI (Server Access Control)"
    },
    {
      "parameters": {
        "jsCode": "// --------------------------------------------\n// Helper: Convert IP → int\n// --------------------------------------------\nfunction ipToInt(ip) {\n    const p = ip.split('.');\n    if (p.length !== 4) return null;\n    return p.reduce((acc, part) => (acc << 8) + parseInt(part, 10), 0) >>> 0;\n}\n\n// --------------------------------------------\n// Helper: Check if IP belongs to CIDR\n// --------------------------------------------\nfunction ipInCidr(ip, cidr) {\n    if (!cidr.includes(\"/\")) return false;\n    const [cidrIp, mask] = cidr.split(\"/\");\n    const m = parseInt(mask, 10);\n\n    const ipInt = ipToInt(ip);\n    const cidrInt = ipToInt(cidrIp);\n    if (ipInt === null || cidrInt === null) return false;\n\n    const maskInt = m === 0 ? 0 : (~0 << (32 - m)) >>> 0;\n    return (ipInt & maskInt) === (cidrInt & maskInt);\n}\n\n// --------------------------------------------\n// Helper: Extract IP or CIDR patterns\n// --------------------------------------------\nfunction extractIpOrCidr(str) {\n    if (typeof str !== \"string\") return [];\n    const regex = /\\b\\d{1,3}(?:\\.\\d{1,3}){3}(?:\\/\\d{1,2})?\\b/g;\n    return str.match(regex) || [];\n}\n\n// --------------------------------------------\n// Helper: service:port detection (flexible)\n// --------------------------------------------\nfunction isServicePortFormat(str) {\n    return /^[A-Za-z0-9_\\-\\.]+\\s*:\\s*\\d{1,5}$/.test(str.trim());\n}\n\n// --------------------------------------------\n// READ NEW INPUT FORMAT\n// --------------------------------------------\nlet alert = $('Extract Fields in Alert').item.json;\n\n// Ensure array\nif (!Array.isArray(alert)) alert = [alert];\n\n// Pick first alert (you only provide one)\nconst alertObj = alert[0] || {};\n\n// Build alert value lists\nconst alertIPs = Array.isArray(alertObj.IPs) ? alertObj.IPs : [];\nconst alertHosts = Array.isArray(alertObj.Hosts) ? alertObj.Hosts : [];\nconst alertProcesses = Array.isArray(alertObj.Processes) ? alertObj.Processes : [];\n\n// Combine hostnames + processes for text searching\nconst alertValues = [...alertHosts, ...alertProcesses];\n\n// --------------------------------------------\n// GET TABLE DATA\n// --------------------------------------------\nconst tableData = $input.first().json.table;\n\nif (!tableData || !Array.isArray(tableData)) {\n    return [{ json: { message: \"No table found in input\", count: 0 } }];\n}\n\n// --------------------------------------------\n// MATCHING ENGINE\n// --------------------------------------------\nfunction findMatchedValues(row, alertValues, alertIPs) {\n    const matched = [];\n    const rowValues = Object.values(row).filter(v => v);\n\n    rowValues.forEach(cell => {\n        const cellStr = cell.toString();\n\n        // Split into parts\n        const parts = cellStr.split(/[,;]+/).map(p => p.trim());\n\n        parts.forEach(part => {\n\n            // ❌ Skip \"ssh : 22\" etc.\n            if (isServicePortFormat(part)) return;\n\n            // TEXT match for Hosts + Processes\n            alertValues.forEach(val => {\n                if (part.includes(val) && !matched.includes(val)) {\n                    matched.push(val);\n                }\n            });\n\n            // IP/CIDR matches\n            const foundPatterns = extractIpOrCidr(part);\n\n            foundPatterns.forEach(pattern => {\n                if (pattern.includes(\"/\")) {\n                    alertIPs.forEach(ip => {\n                        if (ipInCidr(ip, pattern) && !matched.includes(ip)) {\n                            matched.push(ip);\n                        }\n                    });\n                } else if (/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(pattern)) {\n                    if (alertIPs.includes(pattern) && !matched.includes(pattern)) {\n                        matched.push(pattern);\n                    }\n                }\n            });\n\n        });\n    });\n\n    return matched;\n}\n\n// --------------------------------------------\n// RUN MATCHING\n// --------------------------------------------\nlet globalMatchedValues = [];\nconst matchedRows = [];\n\ntableData.forEach(row => {\n    const rowMatches = findMatchedValues(row, alertValues, alertIPs);\n\n    if (rowMatches.length > 0) {\n        matchedRows.push(row);\n        rowMatches.forEach(v => {\n            if (!globalMatchedValues.includes(v)) {\n                globalMatchedValues.push(v);\n            }\n        });\n    }\n});\n\n// --------------------------------------------\n// RETURN OUTPUT\n// --------------------------------------------\nif (matchedRows.length === 0) {\n    return [{\n        json: {\n            message: \"No matching rows found\",\n            count: 0\n        }\n    }];\n}\n\nreturn [{\n    json: {\n        message: \"Matching rows found\",\n        count: matchedRows.length,\n        matchedValues: globalMatchedValues,\n        rows: matchedRows\n    }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        336
      ],
      "id": "bb6105ae-5387-4507-a0be-490564526b77",
      "name": "Get Match AI EI (Trusted Outbound Internet Connections)"
    },
    {
      "parameters": {
        "jsCode": "// --------------------------------------------\n// Helper: Convert IP → int\n// --------------------------------------------\nfunction ipToInt(ip) {\n    const p = ip.split('.');\n    if (p.length !== 4) return null;\n    return p.reduce((acc, part) => (acc << 8) + parseInt(part, 10), 0) >>> 0;\n}\n\n// --------------------------------------------\n// Helper: Check if IP belongs to CIDR\n// --------------------------------------------\nfunction ipInCidr(ip, cidr) {\n    if (!cidr.includes(\"/\")) return false;\n    const [cidrIp, mask] = cidr.split(\"/\");\n    const m = parseInt(mask, 10);\n\n    const ipInt = ipToInt(ip);\n    const cidrInt = ipToInt(cidrIp);\n    if (ipInt === null || cidrInt === null) return false;\n\n    const maskInt = m === 0 ? 0 : (~0 << (32 - m)) >>> 0;\n    return (ipInt & maskInt) === (cidrInt & maskInt);\n}\n\n// --------------------------------------------\n// Helper: Extract IP or CIDR patterns\n// --------------------------------------------\nfunction extractIpOrCidr(str) {\n    if (typeof str !== \"string\") return [];\n    const regex = /\\b\\d{1,3}(?:\\.\\d{1,3}){3}(?:\\/\\d{1,2})?\\b/g;\n    return str.match(regex) || [];\n}\n\n// --------------------------------------------\n// Helper: service:port detection (flexible)\n// --------------------------------------------\nfunction isServicePortFormat(str) {\n    return /^[A-Za-z0-9_\\-\\.]+\\s*:\\s*\\d{1,5}$/.test(str.trim());\n}\n\n// --------------------------------------------\n// READ NEW INPUT FORMAT\n// --------------------------------------------\nlet alert = $('Extract Fields in Alert').item.json;\n\n// Ensure array\nif (!Array.isArray(alert)) alert = [alert];\n\n// Pick first alert (you only provide one)\nconst alertObj = alert[0] || {};\n\n// Build alert value lists\nconst alertIPs = Array.isArray(alertObj.IPs) ? alertObj.IPs : [];\nconst alertHosts = Array.isArray(alertObj.Hosts) ? alertObj.Hosts : [];\nconst alertProcesses = Array.isArray(alertObj.Processes) ? alertObj.Processes : [];\n\n// Combine hostnames + processes for text searching\nconst alertValues = [...alertHosts, ...alertProcesses];\n\n// --------------------------------------------\n// GET TABLE DATA\n// --------------------------------------------\nconst tableData = $input.first().json.table;\n\nif (!tableData || !Array.isArray(tableData)) {\n    return [{ json: { message: \"No table found in input\", count: 0 } }];\n}\n\n// --------------------------------------------\n// MATCHING ENGINE\n// --------------------------------------------\nfunction findMatchedValues(row, alertValues, alertIPs) {\n    const matched = [];\n    const rowValues = Object.values(row).filter(v => v);\n\n    rowValues.forEach(cell => {\n        const cellStr = cell.toString();\n\n        // Split into parts\n        const parts = cellStr.split(/[,;]+/).map(p => p.trim());\n\n        parts.forEach(part => {\n\n            // ❌ Skip \"ssh : 22\" etc.\n            if (isServicePortFormat(part)) return;\n\n            // TEXT match for Hosts + Processes\n            alertValues.forEach(val => {\n                if (part.includes(val) && !matched.includes(val)) {\n                    matched.push(val);\n                }\n            });\n\n            // IP/CIDR matches\n            const foundPatterns = extractIpOrCidr(part);\n\n            foundPatterns.forEach(pattern => {\n                if (pattern.includes(\"/\")) {\n                    alertIPs.forEach(ip => {\n                        if (ipInCidr(ip, pattern) && !matched.includes(ip)) {\n                            matched.push(ip);\n                        }\n                    });\n                } else if (/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(pattern)) {\n                    if (alertIPs.includes(pattern) && !matched.includes(pattern)) {\n                        matched.push(pattern);\n                    }\n                }\n            });\n\n        });\n    });\n\n    return matched;\n}\n\n// --------------------------------------------\n// RUN MATCHING\n// --------------------------------------------\nlet globalMatchedValues = [];\nconst matchedRows = [];\n\ntableData.forEach(row => {\n    const rowMatches = findMatchedValues(row, alertValues, alertIPs);\n\n    if (rowMatches.length > 0) {\n        matchedRows.push(row);\n        rowMatches.forEach(v => {\n            if (!globalMatchedValues.includes(v)) {\n                globalMatchedValues.push(v);\n            }\n        });\n    }\n});\n\n// --------------------------------------------\n// RETURN OUTPUT\n// --------------------------------------------\nif (matchedRows.length === 0) {\n    return [{\n        json: {\n            message: \"No matching rows found\",\n            count: 0\n        }\n    }];\n}\n\nreturn [{\n    json: {\n        message: \"Matching rows found\",\n        count: matchedRows.length,\n        matchedValues: globalMatchedValues,\n        rows: matchedRows\n    }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        528
      ],
      "id": "54e4607c-b54e-4be9-a189-65192b5c9842",
      "name": "Get Match AI EI (User's Access Control)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e0748d29-c457-477d-b522-9e8f01c89c81",
              "leftValue": "={{ $json.message }}",
              "rightValue": "Matching rows found",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        400,
        -432
      ],
      "id": "8e40053f-b033-4904-af45-711461e0b50e",
      "name": "If Find on AI EI (Assets)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e0748d29-c457-477d-b522-9e8f01c89c81",
              "leftValue": "={{ $json.message }}",
              "rightValue": "Matching rows found",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        400,
        -240
      ],
      "id": "ddd3f05a-b359-4432-9f69-c3f3abc75df7",
      "name": "If Find on AI EI (Network Zone)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e0748d29-c457-477d-b522-9e8f01c89c81",
              "leftValue": "={{ $json.message }}",
              "rightValue": "Matching rows found",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        400,
        -48
      ],
      "id": "8e15945e-d8a1-44ea-8000-dd16322b36bc",
      "name": "If Find on  AI EI (Organization Working Time)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e0748d29-c457-477d-b522-9e8f01c89c81",
              "leftValue": "={{ $json.message }}",
              "rightValue": "Matching rows found",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        400,
        144
      ],
      "id": "ff2adfba-2486-4eeb-89ba-bc8a1a56280e",
      "name": "If Find on AI EI (Server Access Control)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e0748d29-c457-477d-b522-9e8f01c89c81",
              "leftValue": "={{ $json.message }}",
              "rightValue": "Matching rows found",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        400,
        336
      ],
      "id": "88d0ec10-d18d-4791-a516-aa4f93cd20bc",
      "name": "If Find on AI EI (Trusted Outbound Internet Connections)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e0748d29-c457-477d-b522-9e8f01c89c81",
              "leftValue": "={{ $json.message }}",
              "rightValue": "Matching rows found",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        400,
        528
      ],
      "id": "b8401a4c-e1f2-4970-8bc5-c6d26a1eb6eb",
      "name": "If Find on AI EI (User's Access Control)"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\n// Collect all processesInfo\nlet processesInfo = [];\n\n// Matching results\nlet matchingResults = [];\n\n// CleanOriginalRule\nlet cleanOriginalRule = null;\n\nfor (const item of items) {\n    const d = item.json;\n\n    if (d.data) {\n        // Collect ALL data items\n        processesInfo.push(d.data);\n\n    } else if (d.CleanOriginalRule) {\n        // Save the CleanOriginalRule\n        cleanOriginalRule = d.CleanOriginalRule;\n\n    } else if (d.message && d.rows) {\n        // Collect all matching results\n        matchingResults.push({\n            message: d.message,\n            count: d.count,\n            matchedValues: d.matchedValues,\n            rows: d.rows\n        });\n    }\n}\n\n// Final merged result\nconst merged = {\n    processesInfo,\n    MatchingResults: matchingResults,\n    CleanOriginalRule: cleanOriginalRule\n};\n\nreturn [\n    {\n        json: merged\n    }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        848,
        240
      ],
      "id": "9a361265-6cd4-49c3-a83c-735633acd9b6",
      "name": "Merge All Data"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "fc8020e9-b63a-4dad-946b-8bedf499b13b",
              "leftValue": "={{ $json.Processes }}",
              "rightValue": "",
              "operator": {
                "type": "array",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -48,
        720
      ],
      "id": "08fa31ed-57b4-4402-8faa-5965895b751b",
      "name": "For Process Existance1"
    },
    {
      "parameters": {
        "url": "={{$vars.SA_API_Base_URL}}/api/v1/enrich_process",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "= Bearer {{ $('Called By Another Workflow').first().json['Access Token'] }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"process\":{\"name\":\"{{ $json.Processes }}\"}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        624,
        816
      ],
      "id": "224dee48-df03-4a7e-bf80-8c18a2286584",
      "name": "Enrich Process1"
    },
    {
      "parameters": {
        "numberInputs": 8
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        624,
        144
      ],
      "id": "9d38d1d8-7b85-4380-825b-85f4b334d91c",
      "name": "Merge1"
    },
    {
      "parameters": {
        "fieldToSplitOut": "Processes",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        176,
        720
      ],
      "id": "6b045bc3-12a6-47a8-baa2-679ae6857f6c",
      "name": "Split Out"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        400,
        720
      ],
      "id": "817b04c6-ab2a-4089-9184-3daeba0ca632",
      "name": "Loop Over Items2"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function Node\n\n// Get Original Rule from specific input branch\nconst originalRule = $('Called By Another Workflow').first().json['Original Rule'];\n\n// Stop if empty\nif (!originalRule || typeof originalRule !== 'object') {\n  return [{ json: { CleanOriginalRule: {} }}];\n}\n\n// ------- Flatten Function -------\nfunction flattenObject(ob) {\n  const toReturn = {};\n\n  for (let i in ob) {\n    if (!ob.hasOwnProperty(i)) continue;\n\n    if (typeof ob[i] === 'object' && ob[i] !== null && !Array.isArray(ob[i])) {\n      const flatObject = flattenObject(ob[i]);\n      for (let x in flatObject) {\n        const newKey =\n          i.replace(/\\./g, '_') + '_' +\n          x.replace(/\\./g, '_');\n        toReturn[newKey] = flatObject[x];\n      }\n    } else {\n      const newKey = i.replace(/\\./g, '_');\n      toReturn[newKey] = ob[i];\n    }\n  }\n  return toReturn;\n}\n\n// ------- Escape JSON strings -------\nfunction escapeString(value) {\n  if (typeof value === 'string') {\n    return value\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\\"/g, '\\\\\"');\n  }\n  return value;\n}\n\n// -------- Flatten and escape the rule --------\nconst flattened = flattenObject(originalRule);\n\nconst escaped = {};\nfor (const key in flattened) {\n  escaped[key] = escapeString(flattened[key]);\n}\n\nreturn [\n  {\n    json: {\n      CleanOriginalRule: escaped\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        992
      ],
      "id": "5964f0f7-ed48-4808-9fe6-bdbafc17f715",
      "name": "Clean Original Rule "
    },
    {
      "parameters": {
        "url": "={{$vars.SA_API_Base_URL}}/api/v1/ai/ex_EI",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "= Bearer {{ $('Called By Another Workflow').first().json['Access Token'] }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\"data\":{\n    \"alert\": {{ $json.CleanOriginalRule.toJsonString() }},\n    \"summary\": {{ $('Called By Another Workflow').first().json.Summery.toJsonString() }},\n    \"results\":{\n          \"data\": {{ $json.processesInfo.toJsonString() }},\n          \"matching_results\": {{ $json.MatchingResults.toJsonString() }}\n}\n}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1072,
        240
      ],
      "id": "ebf9f3d7-9705-4113-b770-8e7b6196b8c6",
      "name": "AI analysis"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "affd4606-b3d5-4983-ad6e-51f10ff3fa31",
              "name": "EI Extra Evidence Result",
              "value": "={{ $json.data[0].detailsMarkdown }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1296,
        240
      ],
      "id": "e46475e6-e194-4f50-a6cc-cb3845ea4650",
      "name": "Return EI IP result"
    }
  ],
  "connections": {
    "Extract Fields in Alert": {
      "main": [
        [
          {
            "node": "Get Page AI EI (Assets)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Page AI EI (Network Zone)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Page AI EI (Organization Working Time)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Page AI EI (Server Access Control)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Page AI EI (Trusted Outbound Internet Connections)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Page AI EI (User's Access Control)",
            "type": "main",
            "index": 0
          },
          {
            "node": "For Process Existance1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Clean Original Rule ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Called By Another Workflow": {
      "main": [
        [
          {
            "node": "Extract Fields in Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Page AI EI (Assets)": {
      "main": [
        [
          {
            "node": "Get content AI EI (Assets) by page ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Page AI EI (Network Zone)": {
      "main": [
        [
          {
            "node": "Get content AI EI (Network Zone) by page ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Page AI EI (Organization Working Time)": {
      "main": [
        [
          {
            "node": "Get content  AI EI (Organization Working Time) by page ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Page AI EI (Server Access Control)": {
      "main": [
        [
          {
            "node": "Get content AI EI (Server Access Control) by page ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Page AI EI (Trusted Outbound Internet Connections)": {
      "main": [
        [
          {
            "node": "Get content AI EI (Trusted Outbound Internet Connections) by page ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Page AI EI (User's Access Control)": {
      "main": [
        [
          {
            "node": "Get content AI EI (User's Access Control) by page ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get content AI EI (Assets) by page ID": {
      "main": [
        [
          {
            "node": "Get Content of AI EI (Assets)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get content  AI EI (Organization Working Time) by page ID": {
      "main": [
        [
          {
            "node": "Get Content of  AI EI (Organization Working Time)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get content AI EI (Network Zone) by page ID": {
      "main": [
        [
          {
            "node": "Get Content of AI EI (Network Zone)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get content AI EI (Server Access Control) by page ID": {
      "main": [
        [
          {
            "node": "Get Content ofAI EI (User's Access Control)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get content AI EI (Trusted Outbound Internet Connections) by page ID": {
      "main": [
        [
          {
            "node": "Get Content of AI EI (Trusted Outbound Internet Connections)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get content AI EI (User's Access Control) by page ID": {
      "main": [
        [
          {
            "node": "Get Content of  AI EI (User's Access Control)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Content of AI EI (Assets)": {
      "main": [
        [
          {
            "node": "Get Match AI EI (Assets)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Content of AI EI (Network Zone)": {
      "main": [
        [
          {
            "node": "Gat Match AI EI (Network Zone)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Content of  AI EI (Organization Working Time)": {
      "main": [
        [
          {
            "node": "Get Match  AI EI (Organization Working Time)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Content ofAI EI (User's Access Control)": {
      "main": [
        [
          {
            "node": "Get Match AI EI (Server Access Control)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Content of AI EI (Trusted Outbound Internet Connections)": {
      "main": [
        [
          {
            "node": "Get Match AI EI (Trusted Outbound Internet Connections)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Content of  AI EI (User's Access Control)": {
      "main": [
        [
          {
            "node": "Get Match AI EI (User's Access Control)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Match AI EI (Assets)": {
      "main": [
        [
          {
            "node": "If Find on AI EI (Assets)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gat Match AI EI (Network Zone)": {
      "main": [
        [
          {
            "node": "If Find on AI EI (Network Zone)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Match  AI EI (Organization Working Time)": {
      "main": [
        [
          {
            "node": "If Find on  AI EI (Organization Working Time)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Match AI EI (Server Access Control)": {
      "main": [
        [
          {
            "node": "If Find on AI EI (Server Access Control)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Match AI EI (Trusted Outbound Internet Connections)": {
      "main": [
        [
          {
            "node": "If Find on AI EI (Trusted Outbound Internet Connections)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Match AI EI (User's Access Control)": {
      "main": [
        [
          {
            "node": "If Find on AI EI (User's Access Control)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Find on AI EI (Assets)": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Find on AI EI (Network Zone)": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "If Find on  AI EI (Organization Working Time)": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "If Find on AI EI (Server Access Control)": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "If Find on AI EI (Trusted Outbound Internet Connections)": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "If Find on AI EI (User's Access Control)": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "Merge All Data": {
      "main": [
        [
          {
            "node": "AI analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "For Process Existance1": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Process1": {
      "main": [
        [
          {
            "node": "Loop Over Items2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Merge All Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "Loop Over Items2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items2": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 6
          }
        ],
        [
          {
            "node": "Enrich Process1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Original Rule ": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 7
          }
        ]
      ]
    },
    "AI analysis": {
      "main": [
        [
          {
            "node": "Return EI IP result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "triggerCount": 0,
  "versionId": "ccd572ac-7708-454f-ad30-4d9c69dcc3e0",
  "owner": {
    "type": "team",
    "teamId": "VkJ1fWswpm3ZmsSH",
    "teamName": "SP"
  },
  "parentFolderId": null,
  "isArchived": false
}